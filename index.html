<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>мини-мир · бесконечный</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            background: #11131f;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            touch-action: none;  /* отключаем скролл */
        }
        .game-wrapper {
            background: #1a1d2b;
            border-radius: 28px;
            padding: 15px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.8);
            max-width: 95vw;
        }
        canvas {
            display: block;
            width: min(85vw, 85vh, 400px);
            height: min(85vw, 85vh, 400px);
            background: #222838;
            border-radius: 24px;
            box-shadow: inset 0 0 0 2px #373e55;
            touch-action: none;
        }
        .joystick-container {
            display: flex;
            justify-content: center;
            margin-top: 12px;
        }
        .joystick {
            width: min(30vw, 30vh, 140px);
            height: min(30vw, 30vh, 140px);
            background: #202536;
            border-radius: 999px;
            box-shadow: 0 6px 0 #0e111c, inset 0 -2px 8px #2d344b;
            touch-action: none;
            position: relative;
        }
        .joystick-thumb {
            position: absolute;
            width: 46px;
            height: 46px;
            background: #b7d0ff;
            border-radius: 999px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 8px #1e253f, 0 0 0 4px #2d3555;
            transition: 0.02s linear;
            will-change: transform;
        }
        .coords {
            color: #7b8bb0;
            text-align: center;
            margin: 8px 0 4px;
            font-size: 12px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
<div class="game-wrapper">
    <canvas id="worldCanvas" width="500" height="500"></canvas>
    <div class="coords">⚫︎ бесконечный мир ⚫︎</div>
    <div class="joystick-container">
        <div class="joystick" id="joystickBase">
            <div class="joystick-thumb" id="joystickThumb"></div>
        </div>
    </div>
</div>

<script>
    (function() {
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const size = 500; // canvas всегда 500x500 пикселей (логических)

        // ------ игрок (круг) ------
        const player = {
            x: 0,
            y: 0,
            radius: 15
        };

        // ------ джойстик (DOM-элементы) ------
        const base = document.getElementById('joystickBase');
        const thumb = document.getElementById('joystickThumb');

        let active = false;
        let maxDist = 35; // максимальное смещение ручки (пикселей в родителе)

        // вектор направления (от -1 до 1)
        const vec = { x: 0, y: 0 };

        // скорость движения
        const SPEED = 4.2;

        // ------ случайные препятствия (генерируем "на лету") ------
        // храним препятствия в объекте-кэше: ключ "x,y" -> блок
        const obstaclesCache = new Map();
        const OBSTACLE_SIZE = 45; // препятствия квадратные ~45px

        function getObstacleKey(cx, cy) {
            // округляем до размера сетки, чтобы одинаковые блоки не дублировались
            const gx = Math.floor(cx / OBSTACLE_SIZE) * OBSTACLE_SIZE;
            const gy = Math.floor(cy / OBSTACLE_SIZE) * OBSTACLE_SIZE;
            return `${gx},${gy}`;
        }

        function getOrCreateObstacle(wx, wy) {
            const key = getObstacleKey(wx, wy);
            if (obstaclesCache.has(key)) {
                return obstaclesCache.get(key);
            }
            // 20% что в этой ячейке будет препятствие
            const hash = (key.split('').reduce((a, b) => a + b.charCodeAt(0), 0));
            if (hash % 5 === 0) { // примерно 20% (5 вариантов)
                const block = {
                    x: Math.floor(wx / OBSTACLE_SIZE) * OBSTACLE_SIZE,
                    y: Math.floor(wy / OBSTACLE_SIZE) * OBSTACLE_SIZE,
                    w: OBSTACLE_SIZE,
                    h: OBSTACLE_SIZE
                };
                obstaclesCache.set(key, block);
                return block;
            } else {
                obstaclesCache.set(key, null); // запоминаем что тут пусто
                return null;
            }
        }

        // проверка столкновения с любым препятствием рядом
        function isColliding(newX, newY, r) {
            // проверяем блоки вокруг (достаточно 3x3 вокруг игрока)
            const cellX = Math.floor(newX / OBSTACLE_SIZE);
            const cellY = Math.floor(newY / OBSTACLE_SIZE);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const wx = (cellX + dx) * OBSTACLE_SIZE + OBSTACLE_SIZE/2;
                    const wy = (cellY + dy) * OBSTACLE_SIZE + OBSTACLE_SIZE/2;
                    const block = getOrCreateObstacle(wx, wy);
                    if (!block) continue;

                    // AABB против круга
                    const nearX = Math.max(block.x, Math.min(newX, block.x + block.w));
                    const nearY = Math.max(block.y, Math.min(newY, block.y + block.h));
                    const dx = newX - nearX;
                    const dy = newY - nearY;
                    const dist = Math.hypot(dx, dy);
                    if (dist < r) return true; // касание
                }
            }
            return false;
        }

        // ------ обновление позиции с коллизиями ------
        function movePlayer(dx, dy) {
            if (dx === 0 && dy === 0) return;

            // пробуем движение по X
            let newX = player.x + dx;
            if (!isColliding(newX, player.y, player.radius)) {
                player.x = newX;
            }

            // пробуем движение по Y
            let newY = player.y + dy;
            if (!isColliding(player.x, newY, player.radius)) {
                player.y = newY;
            }
        }

        // ------ обработчики джойстика (мышь + тач) ------
        function getJoystickDelta(e) {
            e.preventDefault();
            const rect = base.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const dist = Math.hypot(dx, dy);

            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }

            return { dx, dy, dist };
        }

        function startJoy(e) {
            e.preventDefault();
            active = true;
            moveJoy(e);
        }

        function moveJoy(e) {
            if (!active) return;
            e.preventDefault();

            const { dx, dy, dist } = getJoystickDelta(e);
            // двигаем thumb
            thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

            // нормализованный вектор
            if (dist > 5) { // мертвая зона
                vec.x = dx / maxDist;
                vec.y = dy / maxDist;
            } else {
                vec.x = 0;
                vec.y = 0;
            }
        }

        function endJoy(e) {
            e.preventDefault();
            active = false;
            thumb.style.transform = 'translate(-50%, -50%)';
            vec.x = 0;
            vec.y = 0;
        }

        // мышь
        base.addEventListener('mousedown', startJoy);
        window.addEventListener('mousemove', moveJoy);
        window.addEventListener('mouseup', endJoy);
        // тач
        base.addEventListener('touchstart', startJoy, { passive: false });
        window.addEventListener('touchmove', moveJoy, { passive: false });
        window.addEventListener('touchend', endJoy);
        window.addEventListener('touchcancel', endJoy);

        // ------ отрисовка (камера следует за игроком) ------
        function drawWorld() {
            ctx.clearRect(0, 0, size, size);

            // камера: игрок в центре
            const camX = player.x - size/2;
            const camY = player.y - size/2;

            // ----- препятствия (рисуем только видимые) -----
            ctx.fillStyle = '#7c6a5a';
            ctx.shadowColor = '#3a322b';
            ctx.shadowBlur = 14;

            const leftCell = Math.floor((camX) / OBSTACLE_SIZE) - 1;
            const rightCell = Math.floor((camX + size) / OBSTACLE_SIZE) + 1;
            const topCell = Math.floor((camY) / OBSTACLE_SIZE) - 1;
            const bottomCell = Math.floor((camY + size) / OBSTACLE_SIZE) + 1;

            for (let gy = topCell; gy <= bottomCell; gy++) {
                for (let gx = leftCell; gx <= rightCell; gx++) {
                    const worldX = gx * OBSTACLE_SIZE + OBSTACLE_SIZE/2;
                    const worldY = gy * OBSTACLE_SIZE + OBSTACLE_SIZE/2;
                    const block = getOrCreateObstacle(worldX, worldY);
                    if (!block) continue;

                    const screenX = block.x - camX;
                    const screenY = block.y - camY;
                    ctx.fillRect(screenX, screenY, block.w, block.h);
                }
            }

            // ----- игрок -----
            const playerScreenX = size/2; // игрок всегда в центре!
            const playerScreenY = size/2;

            ctx.shadowBlur = 20;
            ctx.shadowColor = '#90b8ff';
            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, player.radius, 0, 2*Math.PI);
            ctx.fillStyle = '#d2e5ff';
            ctx.fill();
            ctx.shadowBlur = 8;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // блик
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(playerScreenX-5, playerScreenY-5, 5, 0, 2*Math.PI);
            ctx.fillStyle = '#ffffff80';
            ctx.fill();

            // маленькая сетка/точки для ощущения бесконечности
            ctx.fillStyle = '#6b7c9e30';
            for (let i = -200; i < 600; i+= 45) {
                for (let j = -200; j < 600; j+= 45) {
                    if ((i + camX) % 90 < 5 && (j + camY) % 90 < 5) {
                        ctx.beginPath();
                        ctx.arc(i, j, 2, 0, 2*Math.PI);
                        ctx.fillStyle = '#5c6f9630';
                        ctx.fill();
                    }
                }
            }
        }

        // ------ игровой цикл ------
        function update() {
            // двигаем игрока по вектору джойстика
            const dx = vec.x * SPEED;
            const dy = vec.y * SPEED;
            movePlayer(dx, dy);

            drawWorld();
            requestAnimationFrame(update);
        }

        update();

        // отключаем контекстное меню на джойстике
        base.addEventListener('contextmenu', e => e.preventDefault());
    })();
</script>
</body>
</html>