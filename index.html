<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Исследование мира · круг и джойстик</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            touch-action: none; /* отключает прокрутку/масштабирование на тач-устройствах */
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: #1a1e2c;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .game-container {
            background: #0b0d15;
            border-radius: 32px;
            padding: 20px;
            box-shadow: 0 20px 35px rgba(0,0,0,0.7);
        }
        canvas {
            display: block;
            width: 600px;
            height: 600px;
            background: #2a2f42;
            border-radius: 24px;
            box-shadow: inset 0 0 0 2px #3d435c, 0 10px 15px -5px black;
            cursor: crosshair;
            touch-action: none;
        }
        .joystick-area {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }
        /* рисуем джойстик через canvas (минимум дизайна, только функция) */
        .joystick-canvas {
            width: 160px;
            height: 160px;
            background: #1e2337;
            border-radius: 999px;
            box-shadow: 0 5px 0 #0c0f19, inset 0 -2px 5px #2f3650;
            touch-action: none;
        }
        .info {
            color: #a3b3d6;
            text-align: center;
            margin-bottom: 12px;
            font-size: 14px;
            letter-spacing: 1px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="info">⦿ Исследуй мир · тащи джойстик</div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div class="joystick-area">
        <canvas id="joystickCanvas" class="joystick-canvas" width="160" height="160"></canvas>
    </div>
</div>

<script>
    (function() {
        // ------ настройки мира ------
        const WORLD_WIDTH = 1200;      // виртуальный мир шире экрана
        const WORLD_HEIGHT = 1200;     // виртуальный мир выше экрана
        const VIEW_SIZE = 600;          // экран (квадрат 600x600)

        // игрок — круг
        const PLAYER_RADIUS = 18;
        let playerPos = { x: WORLD_WIDTH/2, y: WORLD_HEIGHT/2 };  // начнём в центре мира

        // препятствия — несколько квадратных блоков, через которые нельзя пройти
        const obstacles = [
            // x, y, w, h  (координаты в мире)
            { x: 300, y: 200, w: 100, h: 80 },
            { x: 700, y: 500, w: 150, h: 60 },
            { x: 500, y: 800, w: 90, h: 140 },
            { x: 200, y: 950, w: 200, h: 50 },
            { x: 900, y: 250, w: 70, h: 200 },
            { x: 100, y: 500, w: 130, h: 130 },
        ];

        // ------ джойстик ------
        const joystick = {
            active: false,
            baseX: 80, baseY: 80,    // центр базового круга (на canvas 160x160)
            thumbX: 80, thumbY: 80,
            maxDist: 45,
            vector: { x: 0, y: 0 }    // от -1 до 1
        };

        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const joyCanvas = document.getElementById('joystickCanvas');
        const joyCtx = joyCanvas.getContext('2d');

        // ------ определение касаний/мыши для джойстика ------
        function getJoystickCoords(e) {
            const rect = joyCanvas.getBoundingClientRect();
            const scaleX = joyCanvas.width / rect.width;   // соотношение физических пикселей canvas
            const scaleY = joyCanvas.height / rect.height;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // координаты относительно canvas в пикселях canvas (0–160)
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            return { x: Math.min(160, Math.max(0, canvasX)), y: Math.min(160, Math.max(0, canvasY)) };
        }

        function startJoystick(e) {
            e.preventDefault();
            const pos = getJoystickCoords(e);
            joystick.active = true;
            updateThumbFromPos(pos.x, pos.y);
        }

        function moveJoystick(e) {
            if (!joystick.active) return;
            e.preventDefault();
            const pos = getJoystickCoords(e);
            updateThumbFromPos(pos.x, pos.y);
        }

        function endJoystick(e) {
            e.preventDefault();
            joystick.active = false;
            joystick.thumbX = joystick.baseX;
            joystick.thumbY = joystick.baseY;
            joystick.vector = { x: 0, y: 0 };
            drawJoystick();
        }

        function updateThumbFromPos(rawX, rawY) {
            // вектор от базы
            let dx = rawX - joystick.baseX;
            let dy = rawY - joystick.baseY;
            const dist = Math.hypot(dx, dy);

            if (dist > joystick.maxDist) {
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * joystick.maxDist;
                dy = Math.sin(angle) * joystick.maxDist;
            }

            joystick.thumbX = joystick.baseX + dx;
            joystick.thumbY = joystick.baseY + dy;

            // нормализованный вектор (-1..1)
            joystick.vector.x = dx / joystick.maxDist;
            joystick.vector.y = dy / joystick.maxDist;

            drawJoystick();
        }

        function drawJoystick() {
            joyCtx.clearRect(0, 0, 160, 160);
            // база (серый круг)
            joyCtx.beginPath();
            joyCtx.arc(joystick.baseX, joystick.baseY, joystick.maxDist+2, 0, 2*Math.PI);
            joyCtx.fillStyle = '#2f3650';
            joyCtx.fill();
            joyCtx.strokeStyle = '#4a547a';
            joyCtx.lineWidth = 3;
            joyCtx.stroke();

            // ручка (thumb)
            joyCtx.beginPath();
            joyCtx.arc(joystick.thumbX, joystick.thumbY, 18, 0, 2*Math.PI);
            joyCtx.fillStyle = '#9bb7ff';
            joyCtx.shadowColor = '#b3ceff';
            joyCtx.shadowBlur = 12;
            joyCtx.fill();
            joyCtx.shadowColor = 'transparent';
            // маленький блик
            joyCtx.beginPath();
            joyCtx.arc(joystick.thumbX-3, joystick.thumbY-3, 5, 0, 2*Math.PI);
            joyCtx.fillStyle = '#ffffff30';
            joyCtx.fill();
        }

        // подписка на события
        joyCanvas.addEventListener('mousedown', startJoystick);
        joyCanvas.addEventListener('mousemove', moveJoystick);
        joyCanvas.addEventListener('mouseup', endJoystick);
        joyCanvas.addEventListener('mouseleave', endJoystick);

        joyCanvas.addEventListener('touchstart', startJoystick, { passive: false });
        joyCanvas.addEventListener('touchmove', moveJoystick, { passive: false });
        joyCanvas.addEventListener('touchend', endJoystick);
        joyCanvas.addEventListener('touchcancel', endJoystick);

        // ------ игрок и коллизия с препятствиями ------
        function tryMove(newX, newY) {
            // временная проверка: не вышли ли за границы мира (необязательно, но чтоб не убежал в никуда)
            const clampedX = Math.min(WORLD_WIDTH - PLAYER_RADIUS, Math.max(PLAYER_RADIUS, newX));
            const clampedY = Math.min(WORLD_HEIGHT - PLAYER_RADIUS, Math.max(PLAYER_RADIUS, newY));

            // проверка столкновений с препятствиями (AABB против круга)
            for (let ob of obstacles) {
                // ближайшая точка прямоугольника к кругу
                let nearX = Math.max(ob.x, Math.min(clampedX, ob.x + ob.w));
                let nearY = Math.max(ob.y, Math.min(clampedY, ob.y + ob.h));

                let dx = clampedX - nearX;
                let dy = clampedY - nearY;
                let dist = Math.hypot(dx, dy);
                if (dist < PLAYER_RADIUS) {
                    // есть пересечение – отклоняем движение (игрок остаётся на месте)
                    return false;
                }
            }
            // движение допустимо
            playerPos.x = clampedX;
            playerPos.y = clampedY;
            return true;
        }

        // ------ обновление позиции по джойстику ------
        function updatePlayer() {
            const speed = 5.0;  // пикселей за кадр

            let dx = joystick.vector.x * speed;
            let dy = joystick.vector.y * speed;

            if (dx === 0 && dy === 0) return;

            // разделяем движение по X и Y для более гладкой коллизии (пошагово)
            // сначала X
            let newX = playerPos.x + dx;
            let testY = playerPos.y;  // пока без изменения Y

            // пробуем движение по X, если не получается — пробуем только Y чуть позже
            let moveXSuccess = false;
            // проверим отдельно X
            let tempX = newX;
            // проверка границ мира
            tempX = Math.min(WORLD_WIDTH - PLAYER_RADIUS, Math.max(PLAYER_RADIUS, tempX));
            // проверка препятствий (только X)
            let blockedX = false;
            for (let ob of obstacles) {
                let nearX = Math.max(ob.x, Math.min(tempX, ob.x + ob.w));
                let nearY = Math.max(ob.y, Math.min(testY, ob.y + ob.h));
                if (Math.hypot(tempX - nearX, testY - nearY) < PLAYER_RADIUS) {
                    blockedX = true;
                    break;
                }
            }
            if (!blockedX) {
                playerPos.x = tempX;
                moveXSuccess = true;
            }

            // теперь Y
            let newY = playerPos.y + dy;
            newY = Math.min(WORLD_HEIGHT - PLAYER_RADIUS, Math.max(PLAYER_RADIUS, newY));
            let blockedY = false;
            for (let ob of obstacles) {
                let nearX = Math.max(ob.x, Math.min(playerPos.x, ob.x + ob.w));
                let nearY = Math.max(ob.y, Math.min(newY, ob.y + ob.h));
                if (Math.hypot(playerPos.x - nearX, newY - nearY) < PLAYER_RADIUS) {
                    blockedY = true;
                    break;
                }
            }
            if (!blockedY) {
                playerPos.y = newY;
            }
        }

        // ------ отрисовка видимой области (камера следует за игроком) ------
        function drawGame() {
            ctx.clearRect(0, 0, VIEW_SIZE, VIEW_SIZE);

            // центр камеры — игрок. Но камера не выходит за границы мира
            let camX = playerPos.x - VIEW_SIZE/2;
            let camY = playerPos.y - VIEW_SIZE/2;

            // прижимаем, чтобы не было пустоты за краями мира
            camX = Math.max(0, Math.min(WORLD_WIDTH - VIEW_SIZE, camX));
            camY = Math.max(0, Math.min(WORLD_HEIGHT - VIEW_SIZE, camY));

            // рисуем фон (сетка для ощущения движения)
            ctx.fillStyle = '#303649';
            ctx.fillRect(0, 0, VIEW_SIZE, VIEW_SIZE);

            // нарисовать препятствия (в мировых координатах, преобразованные в экранные)
            ctx.fillStyle = '#5f4b3a';
            ctx.shadowColor = '#2d241c';
            ctx.shadowBlur = 12;
            for (let ob of obstacles) {
                // экранные = мировые - camX/camY
                let screenX = ob.x - camX;
                let screenY = ob.y - camY;
                // если объект хоть как-то попадает в экран — рисуем
                if (screenX + ob.w > 0 && screenX < VIEW_SIZE && screenY + ob.h > 0 && screenY < VIEW_SIZE) {
                    ctx.fillRect(screenX, screenY, ob.w, ob.h);
                }
            }
            ctx.shadowColor = 'transparent';

            // рисуем игрока (круг)
            const playerScreenX = playerPos.x - camX;
            const playerScreenY = playerPos.y - camY;

            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, PLAYER_RADIUS, 0, 2*Math.PI);
            ctx.fillStyle = '#a6e0ff';
            ctx.shadowColor = '#4e98d0';
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.shadowBlur = 8;
            ctx.strokeStyle = '#ffffffd0';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.shadowColor = 'transparent';

            // маленький блик на игроке
            ctx.beginPath();
            ctx.arc(playerScreenX-5, playerScreenY-5, 5, 0, 2*Math.PI);
            ctx.fillStyle = '#ffffff60';
            ctx.fill();

            // отметка границ мира (если камера у края — небольшая рамка не обязательна)
            ctx.strokeStyle = '#8088b0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, VIEW_SIZE, VIEW_SIZE);
        }

        // ------ анимация ------
        function gameLoop() {
            updatePlayer();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // инициализация джойстика
        drawJoystick();
        gameLoop();

        // дополнительно: клавиши (wasd / стрелки на всякий случай, но джойстик основоной)
        window.addEventListener('keydown', (e) => {
            // небольшая заглушка, чтобы стрелки не скроллили страницу
            if (e.key.startsWith('Arrow') || ['w','W','a','A','s','S','d','D'].includes(e.key)) {
                e.preventDefault();
            }
        });
    })();
</script>
</body>
</html>